from bio import *
import sys
# import os
import datetime
from python import os, json, argparse, bz2

LIBDIVSUFSORT="lib/libdivsufsort.so.3"
from C import LIBDIVSUFSORT.divsufsort(ptr[byte], Ptr[Int[32]], int)

# Kasai Algorithm
def build_lcp_array(s: str, n, suffix_array: Ptr[Int[32]]) -> List[int]:
    lcp = List[int]([0] * (n))
    rank = List[int]([0] * n)
    k = 0

    for i in range(n):
        rank[int(suffix_array[i])] = i

    for i in range(n):
        if rank[i] == n - 1:
            k = 0
            continue
        j = int(suffix_array[rank[i] + 1])
        while i + k < n and j + k < n and s[i + k] == s[j + k]:
            k += 1
        lcp[rank[i]] = k
        if k > 0:
            k -= 1

    return [0] + [0] + lcp + [0]

def build_suffix_array(Text: str, n):
    print("Building suffix array...  n = " + str(n))
    SA = Ptr[Int[32]](n)
    divsufsort(Text.c_str(), SA, n)

    return SA

def build_index(Text: str):
    n = len(Text)
    SA = build_suffix_array(Text, n)
    LCP = build_lcp_array(Text, n, SA)

    # Temporary dictionary used to store the index
    dictionary = Dict[int, Dict[int, List[int]]]()
    ls = set()
    rs = set()

    for i in range(1, n + 1):
        if (LCP[i] < LCP[i + 1]):
            for k in range(LCP[i] + 1, LCP[i + 1] + 1):            
                # Calculate j > i is the minimum value such that LCP[j] < LCP[i + 1]
                j_min = -1

                for j in range(i + 1, n + 2):
                    if (LCP[j] < k):
                        j_min = j
                        break

                if j <= i:
                    continue

                p: int = int(SA[i])      # Position in the text
                l: int = k               # Length of the string
                r: int = j_min - i       # Number of occurrences

                if l not in dictionary:
                    dictionary[l] = dict()
                
                if r not in dictionary[l]:
                    dictionary[l][r] = list()
                
                dictionary[l][r].append(p)
                # ls.add(l)
                # rs.add(r)

    # return (dictionary, list(ls), list(rs))
    return dictionary

def index_fastq():
    print("Processing FASTQ file...")
    # 
    # 

    reads = list()

    for r in FASTQ('data/1_control_18S_2019_minq7.fastq'):
        sequence = r.read
        reads.append(str(sequence))
        # print((str(sequence) + "$"))

    print("Done. Length of reads = " + str(len(reads)))

    Text = '$'.join(reads)
    n = len(Text)

    print("Length of built Text: " + str(len(Text)))

    build_suffix_array(Text, n)

index_fastq()
