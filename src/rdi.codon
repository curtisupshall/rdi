from bio import *
from python import tqdm
from sa import load_or_build_suffix_array, build_suffix_array
from lcp import load_or_build_lcp_array, build_lcp_array
from index import load_or_generate_repeat_detection_index, generate_repeat_detection_index, write_index, write_kmers

DEFAULT_KMER_SIZE = 12

@tuple
class Read:
    position: int
    record: FASTQRecord

class RepeatDetectonIndex:
    # The file path pointing to the FASTQ file
    __file_path: str
    
    # The suffix array
    __sa: List[Int[32]]
    
    # The LCP array
    __lcp: List[int]
    
    # The text, built from the reads in the FASTQ file
    __text: str
    
    # The length of the text
    __n: int
    
    # The size of the kmers that are recorded for assembly
    __k: int
    
    # The list of reads found in the FASTQ file
    __reads: List[Read]
    
    # `True` if checkpoints should be used, false otherwise
    __use_checkpoints: bool

    def __init__(self: RepeatDetectonIndex, file_path: str, use_checkpoints=True, k=DEFAULT_KMER_SIZE):
        self.__file_path = file_path
        self.__k = k
        self.__text = ''
        self.__n = 0
        self.__reads = List[Read]([])
        self.__use_checkpoints = use_checkpoints
        self.__sa = []
        self.__lcp = []
        
        self.__build_collection(file_path)
    
    def __build_collection(self: RepeatDetectonIndex, file_path: str):
        print("Reading file...")
        records: List[FASTQRecord] = [record for record in FASTQ(file_path)]

        progress = tqdm.tqdm(total=len(records), smoothing=0)

        for record in records:
            progress.update(1)
            self.__add_read(record)

        progress.close()    
        print(f'Building text for {str(len(self.__reads))} reads...')
        seqs = [str(read.record.seq).upper() for read in self.__reads]
        self.__text = '_'.join(seqs)
        
    def __assert_sa(self):
        if len(self.__sa) == 0:
            raise ValueError("Cannot build a repeat detection index with an empty suffix array.")

    def __assert_lcp(self):
        if len(self.__lcp) == 0:
            raise ValueError("Cannot build a repeat detection index with an empty LCP array.")
        
    def build_suffix_array(self):
        if self.__use_checkpoints:
            self.__sa = load_or_build_suffix_array(
                self.__text,
                self.__n,
                self.__file_path
            )
        else:
            self.__sa = build_suffix_array(
                self.__text,
                self.__n,
            )
        
    def build_lcp_array(self):
        if self.__use_checkpoints:
            self.__lcp = load_or_build_lcp_array(
                self.__text,
                self.__n,
                self.__sa,
                self.__file_path
            )
        else:
            self.__lcp = build_lcp_array(
                self.__text,
                self.__n,
                self.__sa,
            )

    def build_repeat_detection_index(self):
        self.__assert_sa()
        self.__assert_lcp()

        if self.__use_checkpoints:
            [dictionary, kmer_counts] = load_or_generate_repeat_detection_index(
                self.__n,
                self.__sa,
                self.__lcp,
                self.__k,
                self.__file_path
            )
        else:
            dictionary, kmer_counts = generate_repeat_detection_index(
                self.__n,
                self.__sa,
                self.__lcp,
                self.__k
            )            
            
        self.__report_kmers(kmer_counts)
        
    def build_contigs():
        

    def __add_read(self, read: FASTQRecord):
        start_position = self.__n
        # self.__text += f'{str(read.seq).upper()}_'
        self.__n += len(read.seq) + 1
        self.__reads.append((start_position, read))
        return

    def __report_kmers(self, kmer_counts: Dict[int, int]):
        self.__assert_sa()
        
        pass
    
    def __report_anchor(self, p: int, l: int, r: int):
        pass
    
    def file_path(self) -> str:
        return self.__file_path
