# Seq imports
from bio import *

# Codon standard library imports
import sys
from threading import Lock
import openmp as omp
import datetime

# Python imports
from python import os, pickle, argparse, bz2, tqdm

# RDI imports
from archive import RdiArchive


INDEX_RDI_EXT = '.idx.rdi'
KMER_LENGTH = 12

def write_index(index, file_path):
    print(f'Writing index to disk... ')
    archive = RdiArchive[Dict[int, Dict[int, List[int]]]]()
    archive.write(index, file_path, INDEX_RDI_EXT)

def load_index(file_path):
    print(f'Loading index from disk... ')
    archive = RdiArchive[Dict[int, Dict[int, List[int]]]]()
    return archive.load(file_path, INDEX_RDI_EXT)

# Generates a string repeat index, based on the given text, its length,
# the suffix array of the text, and the LCP array of the text.
def generate_repeat_detection_index(n: int, SA, LCP):
    CHUNK_SIZE = 2 ** 12
    # CHUNK_SIZE = 2 ** 13

    print("Building RDI dictionary.")

    dictionary = Dict[int, Dict[int, List[int]]]()
    progress = tqdm.tqdm(total=n, smoothing=0, colour='#1ED18B')

    @omp.critical
    def report(records: List[Tuple[int, int, int]]):
        # progress.update(i - progress.n)
        progress.update(CHUNK_SIZE)

        for p, l, r in records:
            if l not in dictionary:
                dictionary[l] = dict()
            
            if r not in dictionary[l]:
                dictionary[l][r] = list()
            
            dictionary[l][r].append(p)

    # @par(schedule='dynamic', num_threads=2, ordered=True)
    for x in range(1, n + 1, CHUNK_SIZE):
        records = list()

        for i in range(x, min(x + CHUNK_SIZE - 1, n) + 1):
            if (LCP[i] < LCP[i + 1]):
                for k in range(LCP[i] + 1, LCP[i + 1] + 1):            
                    # Calculate j > i as the minimum value such that LCP[j] < LCP[i + 1]
                    j = i + 1
                    while j <= n + 1:
                        if (LCP[j] < k):
                            break
                        j += 1      

                    l: int = k                  # Length of the string
                    r: int = j - i              # Number of occurrences
                    p: int = int(SA[i])         # Arbitrary appearance position in the text

                    records.append((p, l, r))

                    if l == KMER_LENGTH:
                        ps: List[int] = [int(p) for p in SA[i:r]]
                        # rdi.report_kmer(KMER_LENGTH, ps)

        report(records)

    progress.close()
    return dictionary
